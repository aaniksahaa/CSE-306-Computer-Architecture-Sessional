
/*
	A1_Group1
	8 February, 2024
*/


#define F_CPU 1000000
#include <util/delay.h>
#include <avr/io.h>

// the following definitions are based on our assigned permutation
// for instance add operation has the opcode 1111

# define add 0x0F
# define addi 0x0B
# define sub 0x0D
# define subi 0x01
# define and 0x08
# define andi 0x07
# define or 0x0C
# define ori 0x0E
# define sll 0x05
# define srl 0x00
# define nor 0x03
# define sw 0x04
# define lw 0x06
# define beq 0x02
# define bneq 0x09
# define j 0x0A


// defining our operations for producing ALUOP and selectors for every MUX
// this array is auto-generated by our python codebase

int control_memory[16] = { 0xd04, 0x304, 0x240, 0x806, 0x110, 0xb04, 0x12c, 0x704, 0x606, 0x280, 0x001, 0x104, 0x406, 0x206, 0x504, 0x006 };

int main(void)
{
	// JTAG is being enabled so that C pins may be used for general IO correctly
	
	MCUCSR |= (1<<JTD);
	MCUCSR |= (1<<JTD);		// JTAG needs to be enabled twice
	
	DDRA=0b11111111;	// all A pins configured as output
	DDRB=0b00000000;	// all B pins configured as input
	DDRC=0b11111111;	// all C pins configured as output
	DDRD=0b00000000;	// all D pins configured as input


	while (1)
	{
		// The most significant 4 bits of instruction denoting the opcode 
		// is fed into the lower 4 bits of PINB
		unsigned int opcode = PINB & 0b00001111;
		
		// extracting upper 8 bits of control
		int control_upper = control_memory[opcode]>>8;
		
		// sending upper 8 bits of control and opcode to PORTC
		PORTC = (control_upper & 0b00001111)|( (opcode<<4) & 0b11110000);
		
		// extracting lower 8 bits of control
		int control_lower = control_memory[opcode]%256;
		
		// sending lower 8 bits of control to PORTA
		PORTA = control_lower & 0b11111111;

		_delay_ms(10);
	}
}